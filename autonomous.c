#pragma config(Hubs,  S1, HTMotor,  HTMotor,  HTMotor,  HTServo)
#pragma config(Sensor, S1,     Controllers,    sensorI2CMuxController)
#pragma config(Sensor, S2,     InfraredL,      sensorHiTechnicIRSeeker1200)
#pragma config(Sensor, S3,     InfraredR,      sensorHiTechnicIRSeeker1200)
#pragma config(Motor,  mtr_S1_C1_1,     motorF,        tmotorTetrix, openLoop, reversed)
#pragma config(Motor,  mtr_S1_C1_2,     motorB,        tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C2_1,     motorL,        tmotorTetrix, openLoop, reversed)
#pragma config(Motor,  mtr_S1_C2_2,     motorR,        tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C3_1,     LED,           tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C3_2,     motorARM,      tmotorTetrix, openLoop, reversed, encoder)
#pragma config(Servo,  srvo_S1_C4_1,    servoArm1,            tServoStandard)
#pragma config(Servo,  srvo_S1_C4_2,    servoArm2,            tServoStandard)
#pragma config(Servo,  srvo_S1_C4_3,    servoArm3,            tServoStandard)
#pragma config(Servo,  srvo_S1_C4_4,    servoArm4,            tServoStandard)
#pragma config(Servo,  srvo_S1_C4_5,    servo5,               tServoNone)
#pragma config(Servo,  srvo_S1_C4_6,    servo6,               tServoNone)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/*
	ART-3938
	Last edited 12.22.12

	Code for autonomous motion
	All "tasks" for motion in teleop mode converted to bools, because, well, asynchronous
	operation should (?) still work is tasks are calling methods, and we don't want
	to rotate/strafe the bot forever -- only a certain distance
*/

#include "JoystickDriver.c"

int zone1Num = 4;
int zone2Num = 7;

void rotate(bool clockwise, int speed)
{
	if(!clockwise){
		speed *= -1;
	}
	motor[motorL] = speed;
	motor[motorR] = -speed;
	motor[motorF] = speed;
	motor[motorB] = -speed;

}

void strafe(float x, float y){
	motor[motorL] = y;
	motor[motorR] = y;
	motor[motorF] = x;
	motor[motorB] = x;
}

void InitializeRobot()
{
	disableDiagnosticsDisplay();
}

task drawScreen()
{
	eraseDisplay();
	nxtDisplayCenteredTextLine(0, "ART-3938");
	nxtDisplayString(0, "MotorF: %d", motor[motorF]);
  nxtDisplayString(1, "motorB: %d", motor[motorB]);
  nxtDisplayString(2, "MotorL: %d", motor[motorL]);
  nxtDisplayString(3, "MotorR: %d", motor[motorR]);
  nxtDisplayString(4, "InfraredL: %d", SensorValue[InfraredL]);
	nxtDisplayString(5, "InfraredR: %d", SensorValue[InfraredR]);
  nxtDisplayCenteredTextLine(7, "ART-3938");
	wait1Msec(100);
}

bool isInZone(int zone, int sensor)
{
	return SensorValue[sensor] == zone;
}

void moveUntilAligned(int x, int y, int zone, int sensor){
	bool aligned = false;
	strafe(x, y);
	while(!aligned){
		if(isInZone(zone, sensor)){
			aligned = true;
			strafe(0, 0);
		}
	}
}

bool realignZone1(){
	if(isInZone(zone1Num, InfraredL)){
		return false;
	}
	else{
		strafe(0, 0);
		if(SensorValue[InfraredL] < zone1Num){
			moveUntilAligned(-10, -10, zone1Num, InfraredL);
		}
		else{
			moveUntilAligned(10, 10, zone1Num, InfraredL);
		}
		return true;
	}
}

void driveDiagonal(){
	int vectorX = 20;
	int vectorY = 10;

	bool aligned = false;
	strafe(vectorX, vectorY);
	while(!aligned){
		if(realignZone1()){
			strafe(vectorX, vectorY);
		}
		if(SensorValue[InfraredR] == zone2Num){
			strafe(0, 0);
			aligned = true;
		}
	}
}

void placeRing(){

}

task AI()
{
	//presumably, here we put the sensor-based stimuli for action to be handled in
	//asynchronous tasks
	wait10Msec(0); //1500 is longest
	moveUntilAligned(-15, 30, zone1Num, InfraredL); //drive forward
	driveDiagonal();
	placeRing();
}

task main()
{
	InitializeRobot();
	waitForStart();
	while(true)
	{
		StartTask(drawScreen);
		StartTask(AI);
	}
}
